=head1 NAME

psh - Developing for Perl Shell


=for README
Please read the perlpod manpage! Pay particular attention to the markup
sequences (B<>, C<>, I<>, etc.).

=head1 COPYRIGHT

Copyright (C) 1999-2000 Gregor N. Purdy. All rights reserved.
This script is free software. It may be copied or modified according
to the same terms as Perl itself.


=head1 DESCRIPTION

=head2 DEBUGGING

The B<-d> option puts B<psh> into "debugging" mode, which prints
diagnostic output. Note that you can also enter/leave this
debugging mode in a running B<psh> via the C<$Psh::debugging> variable.

Possible values for B<-d>/C<$Psh::debugging> are either 0 to disable
it, 1 to enable all debug messages or a string of characters where
each character denotes a certain class of debug messages.

=over 4

=item C<s> - enables printing of information about the chosen strategy for each command

=item C<o> - enables printing of "other" debug info - info which has not been further categorized

=item C<f> - enables printing of the rc files read by psh on startup while it is executed and allows easy tracing of problems in these files

=back

=head2 BUILT-IN FUNCTIONS

The following functions are provided as built-in functions of
C<psh>. You can add an additional built-in called 'C<foo>' by setting the
hash C<$Psh::built_ins{foo}> to a reference to a subroutine. When a line
like "C<foo bar $baz>" is then evaluated by the 'C<built_in>' strategy, the
string 'C<bar $baz>' will be passed to your subroutine as its only
argument. This is precisely the difference between making 'C<foo>' a
built-in as opposed to simply defining a procedure C<main::foo> and
letting the C<eval> strategy call C<foo>: the built-in subroutine will get
the precise input string entered, whereas the ordinary procedure will
of course get arguments that have already been evaluated by the Perl
evaluator. Which you want depends on the nature of the function being
defined.

If C<$Psh::built_ins{foo}> does not exist, but
C<&Psh::Builtins::bi_foo> is defined, then foo will still be
considered a builtin calling that function. This is primarily to
ensure that the original builtins are always accessible, for example
if they have been aliased and unaliased.

"Fallback builtins" are provided similarly to this last option: "foo"
is a fallback builtin if C<&Psh::Builtins::Fallback::bi_foo> is
defined.

For a list of the predefined B<psh> builtins, see L<Psh::Builtins> or use the "help" command from within B<psh>.

=head2 DEFINING EVALUATION STRATEGIES

There are two hashes, I<%Psh::strategy_which> and I<%Psh::strategy_eval>.
An evaluation strategy called "C<foo>" is implemented by putting a
subroutine object in each of these hashes keyed by "foo". The first
subroutine should accept a reference to a string (the exact input
line) and a reference to an array of strings (the array of "words" in
the input line produced by C<&Psh::decompose>, provided as a convenience
so that each individual strategy doesn't have to recompute this). It
should return a string, which should be empty if the strategy does not
apply to that input line, and otherwise should be an arbitrary
non-null string describing how that strategy applies to that line. It
is guaranteed that the string passed in will contain some
non-whitespace, and that the first string in the array of words is
non-empty.

The I<$strategy_eval{foo}> routine accepts the same two first arguments
and a third argument, which is the string returned by
I<$strategy_which{foo}>. It should do the evaluation, and return the
result. Note that the I<$strategy_eval> function will be evaluated in
an array context. 



=cut
