#! /usr/local/bin/perl
#
# psh - Perl Shell
#
# TODO: The background symbol & is currently handled in a hackish way
# in three different places in this file. Could these be unified/made
# less of a hack?
#
# Similarly, there are three slight variants of code to fork. Could
# these be unified/cleaned up?
#
# Copyright (C) 1999 Gregor N. Purdy. All rights reserved.
# This script is free software. It may be copied or modified according
# to the same terms as Perl itself.
#

package psh;

use vars qw($VERSION);
$VERSION   = '0.004pre1';

use Config;
use Cwd;
use Cwd 'chdir';
use FileHandle;
use Getopt::Std;
use IPC::Open2;
use POSIX qw(:sys_wait_h getpid setpgid tcgetpgrp tcsetpgrp);

#use POSIX qw(tcsetpgrp);



##############################################################################
##############################################################################
##
## Variables
##
##############################################################################
##############################################################################



#
# Global Variables:
#
# The use vars variables are intended to be accessible to the user via
# explicit psh:: package qualification. They are documented in the pod
# page. 
#
#
# The other global variables are private, lexical variables.
#

use vars qw($bin $news_file $cmd $prompt $echo $host $debugging
	    $perlfunc_expand_arguments $executable_expand_arguments
	    $history_file $save_history $history_length
	    $eval_preamble $currently_active
	    @val @wday @mon @strategies 
	    %prompt_vars %built_ins %strategy_which %strategy_eval);


#
# Private, Lexical Variables:
#

my %opt;
my $default_prompt         = '\s\$ ';
my @default_strategies     = qw(comment bang built_in executable eval);
my $input;
my %job_commands           = ();
my %job_running            = ();
my @jobs_order             = ();
my $readline_saves_history = 0;
my $last_dir               = '.'; # By default 'cd -' won't change directory at all.
my $term;                         # Term::ReadLine object.
my @completion_buffer      = ();
my %perl_builtins;
my %perl_builtins_noexpand;



##############################################################################
##############################################################################
##
## SETUP
##
##############################################################################
##############################################################################



$SIG{'INT'}   = \&signal_handler;
$SIG{'QUIT'}  = \&signal_handler;
$SIG{'USR1'}  = \&signal_handler;
$SIG{'USR2'}  = \&signal_handler;
$SIG{'CONT'}  = \&signal_handler;
$SIG{'STOP'}  = \&signal_handler;
$SIG{'TSTP'}  = \&signal_handler;
$SIG{'TTIN'}  = \&signal_handler;
$SIG{'TTOU'}  = \&signal_handler;
$SIG{'CHLD'}  = \&ignore_handler;
$SIG{'WINCH'} = \&resize_handler;


#
# Parse the command line and deal with the options except -r, which is
# handled in the MAIN program below. We do this part vary early in this
# file so that the results apply to all the setting up we do before the
# MAIN program.
#

getopts('dwr:', \%opt);


#
# -w is "warnings mode":
#

if ($opt{'w'}) {
	print_out("Simulating -w switch and strict\n");

	$^W = 1;    # Simulate the -w command-line switch
	use strict; # Turned on when debugging
}

#
# -d is "debug mode":
#

if ($opt{'d'}) { $debugging = 1; }
else           { $debugging = 0; }

print_debug("Debugging!\n");


#
# Set up Term::ReadLine:
#

eval "use Term::ReadLine;";

if ($@) {
	$term = undef;
	print_debug("Term::ReadLine not available.\n");
} else {
	$term = Term::ReadLine->new('psh');
	$term->MinLine(10000);   # We will handle history adding
                                 # ourselves (undef causes trouble). 
	$term->ornaments(0);
	print_debug("Using ReadLine: ", $term->ReadLine(), "\n");
	if ($term->ReadLine() eq "Term::ReadLine::Gnu") {
		$readline_saves_history = 1;
		$term->StifleHistory($history_length); # Limit history
		$term->Attribs->{attempted_completion_function} = \&custom_completion;
	}
}


#
# Set up Term::Size:
#

eval "use Term::Size 'chars'";

if ($@) { print_debug("Term::Size not available.\n");   }
else    { print_debug("Using &Term::Size::chars().\n"); }



##############################################################################
##############################################################################
##
## SUBROUTINES: Variable expansion and evaluation
##
## IMPORTANT: the following functions, which do "eval"s of arbitrary
## expressions used in psh's read-eval loop, must come before the
## declarations of global lexical variables used in this
## file. Otherwise, those lexical variables are in scope in the evals,
## and in fact would mask main:: package variables! (Try '$term = 7;
## print($term);' in an older version of psh if you don't believe this.)
##
## Note that these routines use no lexical variables themselves, for
## the same reason.
##
##############################################################################
##############################################################################



#
# array variable_expansion (arrayref WORDS)
#
# For each element x of the array referred to by WORDS, substitute
# perl variables that appear in x respecting the quoting symbols ' and
# ", and return the array of substituted values. Substitutions inside
# quotes always return a single element in the resulting array;
# outside quotes, the result is split() and pushed on to the
# accumulating array of substituted values
#

sub variable_expansion
{
	local ($psh::arref) = @_;
	local @psh::retval  = ();
	local $psh::word;

	for $psh::word (@{$psh::arref}) {
		if    ($psh::word =~ m/^\'/) { push @psh::retval, $psh::word; }
		elsif ($psh::word =~ m/^\"/) { 
			local $psh::val = eval("$psh::eval_preamble $psh::word");

			if ($@) { push @psh::retval, $psh::word; }
			else    { push @psh::retval, "\"$psh::val\""; }
		} else {
			local $psh::val = eval("$psh::eval_preamble \"$psh::word\"");

			if ($@) { push @psh::retval, $psh::word; }
			else    { push @psh::retval, split(" ",$psh::val); }
		}
	}

	return @psh::retval;
}


#
# array protected_eval(string EXPR, string FROM) 
#
# Evaluates "$psh::eval_preamble EXPR", handling trapped signals and
# printing errors properly. The FROM string is passed on to
# handle_message to indicate where errors came from.
# 
# If EXPR ends in an ampersand, it is stripped and the eval is done in
# a forked copy of perl.
#

sub protected_eval
{
	#
	# Local package variables because lexical variables here mask
	# variables of the same name in main!!
	#
 
	local ($psh::string, $psh::from) = @_;
	local $psh::currently_active     = 0;
	local $psh::fgflag               = 1;

	if ($psh::string =~ m/^(.*)\&\s*$/) {
		$psh::string = $1;
		$fgflag      = 0;
	}

	local @psh::result = ();

	if ($fgflag) {
		$currently_active = -1; # So the handlers know we are evaluating perl.
		@psh::result = eval "$psh::eval_preamble $psh::string"; 
		handle_message($@, $psh::from);
		$currently_active = 0;
	} else {
		local $psh::pid;

		unless ($psh::pid = fork) {
			#
			# Child
			#

			open(STDIN,"-");
			open(STDOUT,">-");
			open(STDERR,">-");
			remove_signal_handlers();
			setpgid(getpid(), getpid());

			#
			# Something like this is vital as otherwise Control-C
			# (etc.) may automatically be sent to me, the
			# child. Bash does this to the jobs it forks off.
			#

			eval "$psh::eval_preamble $psh::string";
			if ($@) { exit -1; }
			exit 0;
		}

		#
		# Still the parent psh:
		#

		setpgid($psh::pid, $psh::pid);
		create_job($psh::pid, $psh::string, 1);
	}

	return @psh::result;
}



##############################################################################
##############################################################################
##
## SUBROUTINES: Support
##
##############################################################################
##############################################################################



#
# string abs_path(string DIRECTORY)
#
# expands the argument DIRECTORY into a full, absolute pathname.
#

eval "use Cwd 'fast_abs_path';";
if (!$@) {
  print_debug("Using &Cwd::fast_abs_path()\n");
  sub abs_path { return fast_abs_path(@_); }
} else {
    sub abs_path
      {
	my $dir = shift;
	
	$dir = '~' unless defined $dir and $dir ne '';
	
	if ($dir =~ m|^(~([a-zA-Z0-9-]*))(.*)$|) {
	  my $user = $2; 
	  my $rest = $3;
	  
	  my $home;
	  
	  if ($user eq '') { $home = $ENV{HOME}; }
	  else             { $home = (getpwnam($user))[7]; }
	  
	  if ($home) { $dir = "$home$rest"; } # If user's home not found, leave it alone.
	}
	
	if (!$dir =~ m|^/|) { $dir = cwd . '/', $dir }
	
	return $dir;
      }
}


#
# string which(string FILENAME)
#
# search for an occurrence of FILENAME in the current path as given by 
# $ENV{PATH}. Return the absolute filename if found, or undef if not.
#

{
	#
	# "static variables" for which() :
	#

	my $last_path_cwd = '';
	my @absed_path    = ();
	my %hashed_cmd    = ();

	sub which
    {
		my $cmd      = shift;

		print_debug("[which $cmd]\n");

		if ($cmd =~ m|/|) {
			my $try = abs_path($cmd);
			if ((-x $try) and (! -d _)) { return $try; }
			return undef;
		}

		if ($last_path_cwd ne ($ENV{PATH} . cwd())) {
			$last_path_cwd = $ENV{PATH} . cwd();
			@absed_path    = ();
			$hashed_cmd    = ();

			my @path = split(':', $ENV{PATH});

			foreach my $dir (@path) {
				push @absed_path, abs_path($dir);
			}
		}

		if (exists($hashed_cmd{$cmd})) { return $hashed_cmd{$cmd}; }
      
		foreach my $dir (@absed_path) {
			my $try = "$dir/$cmd";

			if ((-x $try) and (!-d _)) { 
				$hashed_cmd{$cmd} = $try;
				return $try; 
			}
		}
      
		$hashed_cmd{$cmd} = undef;

		return undef;
	}
}



##############################################################################
##############################################################################
##
## SUBROUTINES: Built-Ins
##
##############################################################################
##############################################################################



#
# int builtin_cd(string DIR)
#
# Changes directories to the given DIR; '-' is interpreted as the
# last directory that psh was in
#

sub builtin_cd
{
	my $in_dir = shift;
	my $dir = $in_dir;

	$dir = $last_dir if $dir eq '-';
	$dir = abs_path($dir);

	if ((-e $dir) and (-d _)) {
		if (-x _) {
			$last_dir = cwd;
			chdir $dir;
		} else {
			print_error("psh: $in_dir: Permission denied\n");
			return 1;
		}
	} else  {
		print_error("psh: $in_dir: No such directory\n");
		return 1;
	}

	return 0;
}


#
# int builtin_kill(string COMMAND)
#

sub builtin_kill
{
	my @args = split(' ',$_[0]);
	my $sig;
	my $pid;

	if (scalar(@args) == 1) {
		$pid = $args[0];
		$sig = 'TERM';
	} elsif (scalar(@args) == 2) {
		($sig, $pid) = @args;
	} else {
		print_error("kill: usage: kill <sig> <pid>\n");
		return 1;
	}

	if ($pid =~ m|^%(\d+)$|) {
		my $temp = $1 - 1;

		if (($temp < 0) or ($temp >= scalar(@jobs_order))) {
			print_out("pid   = $pid\n");
			print_out("temp  = $temp\n");
			print_out("#jobs = ", scalar(@jobs_order), "\n");
			print_error("kill: No such job $pid\n");
			return 1;
		}

		$pid = $jobs_order[$temp];
	}

	if ($pid =~ m/\D/) {
		print_error("kill: Unknown job specification $pid\n");
		return 1;
	}

	if ($sig ne 'CONT' and  job_exists($sig) and !is_job_running($pid)) {
		#Better wake up the process so it can respond to this signal
		continue_job($pid);
	}

	if (kill($sig, $pid) != 1) {
		print_error("kill: Error sending signal $sig to process $pid\n");
		return 1;
	}

	if ($sig eq 'CONT' and job_exists($pid)) {
		record_job_running($pid, 1);
	}

	return 0;
}


#
# int builtin_which(string COMMAND)
#

sub builtin_which
{
	my $cmd   = shift;

	print_debug("[builtin_which $cmd]\n");

	if (!defined($cmd) or $cmd eq '') {
		print_error("which: requires a command or command line as argument\n");
		return 1;
	}
  
	my @words = decompose($cmd);

	for my $strat (@psh::strategies) {
		if (!defined($psh::strategy_which{$strat})) {
			print_warning("$bin: WARNING: unknown strategy '$strat'.\n");
			next;
		}

		my $how = &{$psh::strategy_which{$strat}}(\$cmd,\@words);

		if ($how) {
			print_out("$cmd evaluates under strategy $strat by: $how\n");
			return 0;
		}
	}

	print_warning("which: can't determine how to evaluate $cmd\n");

	return 1;
}


#
# int builtin_alias(string COMMAND)
#
# TODO: Handles alias ls=ls -F fine, but doesn't do well with alias ls='ls -F'.
# Generally, we need work on quoting issues.
#

sub builtin_alias
{
	my ($command, $text) = split('[ =]', "@_", 2);

	if (($command eq "") && ($text eq "")) {
		print_out("Alias List currently not implemented anymore.\n");

		# This was already in my alias code but vanished with the move
		# to simulate aliases as a built-in. I recommend adding my
		# old code as new evaluation strategy
	} else {
		print_debug("[[ Aliasing '$command' to '$text']]\n");
		# my apologies for the gobbledygook
		my $string_to_eval = "\$psh::built_ins{$command} = "
			. " sub { local \$psh::built_ins{$command} = undef; psh::evl(\"$text" 
			. ' @_"); }';
		print_debug("[[ alias evaluating: $string_to_eval ]]\n");
		eval($string_to_eval);
		if ($@) { print_error($@); return 1; }
	}

	return 0;
}


#
# void builtin_fg(int JOB_NUMBER)
#

sub builtin_fg
{
	my $arg = shift;

	$arg = -1 if (!defined($arg) or ($arg eq ''));
	$arg =~ s/\%//;

	restart_job(1, $arg - 1);
}


#
# int builtin_bg(string JOB)
#

sub builtin_bg
{
	my $arg = shift;

	$arg = -1 if (!defined($arg) or ($arg eq ''));
	$arg =~ s/\%//;

	restart_job(0, $arg - 1);
}


#
# void builtin_jobs()
#
# Checking whether jobs are running might print reports that
# jobs have stopped, so accumulate the job list and print it
# all at once so it's readable.
#

sub builtin_jobs {
	my $joblist = '';

	for($i = 0; $i <= $#jobs_order; $i++) {
		my $visindex = $i+1;
		my $pid      = $jobs_order[$i];
		my $command  = get_job_command($pid);

#		next unless $tmp;
	    
		$joblist .= "[$visindex] $pid $command";

		if (is_job_running($pid)) { $joblist .= "\n"; }
		else                      { $joblist .= " (stopped)\n"; }
	}

	if (!$joblist) { $joblist = "No jobs.\n"; }

	print_out($joblist);

	return undef;
}


#
# void builtin_exit(int RETURN_CODE)
#
# TODO: What if a string is passed in?
#

sub builtin_exit
{
	my $result = shift;
	$result = 0 unless defined($result) && $result;

	if ($save_history && $readline_saves_history) {
		$term->WriteHistory($psh::history_file);
	}
	
	#TODO: should there be a .psh_logout file of commands?

	exit $result;
}


#
# void builtin_source(string LIST_OF_FILES)
#

sub builtin_source
{
	local $echo = 0;

	for my $file (split(' ',$_[0])) { process_file($file); }

	return undef;
}


#
# void builtin_readline(string IGNORED)
#
# Interface to the readline module being used. Currently very rudimentary 
#
# TODO: How can we print out the current bindings in an
# ReadLine-implementation-independent way? We should allow rebinding
# of keys if Readline interface allows it, etc.
#

sub builtin_readline
{
	print_out("Using ReadLine: ", $term->ReadLine(), ", with features:\n");

	my $featureref = $term->Features();

	for my $feechr (keys %{$featureref}) {
		print_out("  $feechr => ${$featureref}{$feechr}\n");
	}

	return undef;
}



##############################################################################
##############################################################################
##
## SUBROUTINES: Command-line processing
##
##############################################################################
##############################################################################



#
# array decompose(string LINE)
#
# decompose breaks LINE into pieces much like split(' ',LINE), except
# that single and double quotes prevent splitting on internal
# whitespace. It returns the array of pieces.  Thus, if LINE is
#    echo fred(joe, "Happy Days", ' steve"jan ', "\"Oh, no!\"")
# then decompose should break it at the following places marked by
# vertical bars:
#    echo|fred(joe,|"Happy Days",|' steve"jan',|"\"Oh, no!\"")
#
# As a special hack, if LINE ends in an ampersand followed by
# whitespace, the ampersand is split off into its own word.
#

sub decompose 
{
    my ($line) = @_;

    $line =~ s/^\s*//; # remove initial whitespace, shouldn't be in any piece

    my @pieces = ('');

    while ($line) {
      my ($prefix,$delimiter,$rest) =
	($line =~ m/^(\S*?)(\s+|(?<!\\)\"|(?<!\\)\')(.*)$/s);
      if (!defined($delimiter)) { # no delimiter found, so all one piece
	$pieces[scalar(@pieces)-1] .= $line;
	$line = '';
      } elsif ($delimiter =~ m/\s+/) {
	$pieces[scalar(@pieces)-1] .= $prefix;
	push @pieces, '';
	$line = $rest;
      } else { # $delimiter is " or '
	my ($restOfQuote,$remainder) = 
	  ($rest =~ m/^(.*?(?<!\\)$delimiter)(.*)$/s);
	if (defined($restOfQuote)) {
	  $pieces[scalar(@pieces)-1] .= "$prefix$delimiter$restOfQuote";
	  $line = $remainder;
	} else { # can't find matching delimiter
	  $pieces[scalar(@pieces)-1] .= $line;
	  $line = '';
	}
      } 
    }
    my $lastpiece = pop @pieces;
    if ($lastpiece =~ m/^(.*)\&\s*$/) {
      if ($1) { push @pieces, $1; }
      push @pieces, '&';
    } else { push @pieces, $lastpiece; }
    return @pieces;
}


#
# glob_expansion()
#
# LINE EXPANSIONS:
#
# If we're going to be a shell, let's act like a shell. The idea here
# is to provide expansion functions that individual evaluation
# strategies can use on the argument list to perform operations
# similar to the ones a shell argument list undergoes. Each of these
# functions should take a reference to an array of "words" and return
# a solid (to be conservative, as opposed to modifying in place) array of
# "expanded words".
#
# Bash defines eight types of expansion in its manpage: brace
# expansion, tilde expansion, parameter and variable expansion,
# command substitution, arithmetic expansion, word splitting,
# pathname expansion, and process expansion.
#
# Of these, arithmetic expansion makes no sense in Perl. Word
# splitting should happen "on the fly", i.e., the array returned by
# one of these functions might have more elements than the argument
# did. Since the perl builtin "glob" handles brace, tilde and pathname
# expansion, here's a glob_expansion function that covers all of
# those. Also a variable_expansion function that handles substituting
# in the values of Perl variables. That leaves only:
#
# TODO: command_expansion (i.e., backticks. For this,
# backticks would have to be added to decompose as a recognized quote
# character), process_expansion
#
# TODO: should some of these line-processing actions happen in a
# uniform way, or should things simply be left to each evaluation strategy
# as psh currently works?
#
# array glob_expansion (arrayref WORDS)
#
# For each element x of the array referred to by WORDS, such that x
# is not quoted, push glob(x) onto an array, and return the collected array.
#

sub glob_expansion
{
	my ($arref) = @_;
	my @retval  = ();

	for my $word (@{$arref}) {
		if ($word =~ m/['"']/ # if it contains quotes
			or ($word !~ m/{.*}|\[.*\]|[*?]/)) { # or no globbing characters
			push @retval, $word;  # don't try to glob it
		} else { 
			push @retval, glob($word); 
		}
	}

	return @retval;
}


#
# variable_expansion is defined above for technical reasons; see
# comments there
#

# EVALUATION STRATEGIES: We have two hashes, %strategy_which and
#  %strategy_eval; an evaluation strategy called "foo" is implemented
#  by putting a subroutine object in each of these hashes keyed by
#  "foo". The first subroutine should accept a reference to a string
#  (the exact input line) and a reference to an array of strings (the
#  'psh::decompose'd line, provided as a convenience). It should
#  return a string, which should be null if the strategy does not
#  apply to that input line, and otherwise should be an arbitrary
#  non-null string describing how that strategy applies to that
#  line. It is guaranteed that the string passed in will contain some
#  non-whitespace, and that the first string in the array is
#  non-empty.
#
# The $strategy_eval{foo} routine accepts the same first two arguments
#  and a third argument, which is the string returned by
#  $strategy_which{foo}. It should do the evaluation, and return the
#  result. Note that the $strategy_eval function will be evaluated in
#  an array context. Note also that if $psh::echo is true, the
#  process() function below will print and store away any
#  result that is not undef.
#
# @psh::strategies contains the evaluation strategies in order that
# will be called by evl().
#
#
# TODO: Is there a better way to detect Perl built-in-functions and
# keywords than the following? Surprisingly enough,
# defined(&CORE::abs) does not work, i.e., it returns false.
#

%perl_builtins = qw( -X 1 abs 1 accept 1 alarm 1 atan2 1 bind 1
binmode 1 bless 1 caller 1 chdir 1 chmod 1 chomp 1 chop 1 chown 1 chr
1 chroot 1 close 1 closedir 1 connect 1 continue 1 cos 1 crypt 1
dbmclose 1 dbmopen 1 defined 1 delete 1 die 1 do 1 dump 1 each 1
endgrent 1 endhostent 1 endnetent 1 endprotoent 1 endpwent 1
endservent 1 eof 1 eval 1 exec 1 exists 1 exit 1 exp 1 fcntl 1 fileno
1 flock 1 for 1 foreach 1 fork 1 format 1 formline 1 getc 1 getgrent 1
getgrgid 1 getgrnam 1 gethostbyaddr 1 gethostbyname 1 gethostent 1
getlogin 1 getnetbyaddr 1 getnetbyname 1 getnetent 1 getpeername 1
getpgrp 1 getppid 1 getpriority 1 getprotobyname 1 getprotobynumber 1
getprotoent 1 getpwent 1 getpwnam 1 getpwuid 1 getservbyname 1
getservbyport 1 getservent 1 getsockname 1 getsockopt 1 glob 1 gmtime
1 goto 1 grep 1 hex 1 import 1 if 1 int 1 ioctl 1 join 1 keys 1 kill 1
last 1 lc 1 lcfirst 1 length 1 link 1 listen 1 local 1 localtime 1 log
1 lstat 1 m// 1 map 1 mkdir 1 msgctl 1 msgget 1 msgrcv 1 msgsnd 1 my 1
next 1 no 1 oct 1 open 1 opendir 1 ord 1 pack 1 package 1 pipe 1 pop 1
pos 1 print 1 printf 1 prototype 1 push 1 q/STRING/ 1 qq/STRING/ 1
quotemeta 1 qw/STRING/ 1 qx/STRING/ 1 rand 1 read 1 readdir 1 readlink
1 recv 1 redo 1 ref 1 rename 1 require 1 reset 1 return 1 reverse 1
rewinddir 1 rindex 1 rmdir 1 s/// 1 scalar 1 seek 1 seekdir 1 select 1
semctl 1 semget 1 semop 1 send 1 setgrent 1 sethostent 1 setnetent 1
setpgrp 1 setpriority 1 setprotoent 1 setpwent 1 setservent 1
setsockopt 1 shift 1 shmctl 1 shmget 1 shmread 1 shmwrite 1 shutdown 1
sin 1 sleep 1 socket 1 socketpair 1 sort 1 splice 1 split 1 sprintf 1
sqrt 1 srand 1 stat 1 study 1 sub 1 substr 1 symlink 1 syscall 1
sysread 1 system 1 syswrite 1 tell 1 telldir 1 tie 1 time 1 times 1
tr/// 1 truncate 1 uc 1 ucfirst 1 umask 1 undef 1 unless 1 unlink 1
unpack 1 unshift 1 untie 1 until 1 use 1 utime 1 values 1 vec 1 wait 1
waitpid 1 wantarray 1 warn 1 while 1 write 1 y/// 1 );


#
# The following hash contains names where the arguments should never
# undergo expansion in the sense of
# $psh::perlfunc_expand_arguments. For example, any perl keyword where
# an argument is interpreted literally by Perl anyway (such as "use":
# use $yourpackage; is a syntax error) should be on this
# list. Flow-control keywords should be here too.
#
# TODO: Is this list complete ?
#

%perl_builtins_noexpand = qw( continue 1 do 1 for 1 foreach 1 goto 1 if 1 last 1 local 1 my 1 next 1 package 1 redo 1 sub 1 until 1 use 1 while 1);


#
# bool needs_double_quotes (string WORD) 
#
# Returns true if WORD needs double quotes around it to be interpreted
# in a "shell-like" manner when passed to eval. This covers barewords,
# expressions that just have \-escapes and $variables in them, and
# filenames. 
#
# TODO: right now this is pretty much of a hack. Could it be improved?
#        For example, 'print hello \n' on the command line gets double
#        quotes around hello and \n, so that it ends up doing
#        print("hello","\n") which looks nice but is a surprise to
#        bash users. Perhaps backslash simply shouldn't be in the list
#        of OK characters?

sub needs_double_quotes
{
	my ($word) = @_;

	if ($word =~ m/[a-zA-Z]/                     # if it has some letters
		and $word =~ m|^[$.:a-zA-Z0-9/.\\]*$|) { # and only these characters 
		return 1;                                # then double-quote it
	}

	return 0;
}


#
# bool matches_perl_binary(string FILENAME)
#
# Returns true if FILENAME referes directly or indirectly to the
# current perl executable
#

sub matches_perl_binary
{
	my ($filename) = @_;

	#
	# Chase down symbolic links, but don't crash on systems that don't
	# have them:
	#

	if ($Config{d_readlink}) {
		my $newfile;
		while ($newfile = readlink($filename)) { $filename = $newfile; }
	}

	if ($filename eq $Config{perlpath}) { return 1; }

	my ($perldev,$perlino) = (stat($Config{perlpath}))[0,1];
	my ($dev,$ino) = (stat($filename))[0,1];

	#
	# TODO: Does the following work on non-Unix OS ?
	#

	if ($perldev == $dev and $perlino == $ino) { return 1; }

	return 0;
}


#
# EVALUATION STRATEGIES:
#

%strategy_which = (
	'bang'     => sub { if (${$_[1]}[0] =~ m/^!/)  { return 'system';  } return ''; },

	'comment'  => sub { if (${$_[1]}[0] =~ m/^\#/) { return 'comment'; } return ''; },

	'built_in' => sub {
		 my $fnname = ${$_[1]}[0];

		 if (defined($built_ins{$fnname})) { return "(built-in $fnname)" }

		 return '';
	},

	'perlfunc' => sub {
		my $fnname = ${$_[1]}[0];

		if (exists($perl_builtins{$fnname}) 
			or defined(&{"main::$fnname"})) {
			my $copy = ${$_[0]};

			#
			# remove braces containing no whitespace
			# and at least one comma in checking,
			# since they might be for brace expansion
			#

			$copy =~ s/{\S*,\S*}//g;

			if (!$perlfunc_expand_arguments
				or exists($perl_builtins_noexpand{$fnname})
				or $copy =~ m/[(){},]/) {
				return ${$_[0]};
			} else {                     # no parens, braces, or commas, so  do expansion
				my $ampersand = '';
				my $lastword  = pop @{$_[1]};

				if ($lastword eq '&') { $ampersand = '&';         }
				else                  { push @{$_[1]}, $lastword; }

				shift @{$_[1]};          # OK to destroy command line since we matched

				#
				# No need to do variable expansion, because the whole thing
				# will be evaluated later.
				#

				my @args = glob_expansion($_[1]);

				#
				# But we will quote barewords, expressions involving
				# $variables, filenames, and the like:
				#

				foreach (@args) {
					if (needs_double_quotes($_)) { $_ = "\"$_\""; } 
				}

				my $possible_proto = '';

				if (defined($perl_builtins{$fnname})) {
					$possible_proto = prototype("CORE::$fnname");
				} else {
					$possible_proto = prototype($fnname);
				}

				#
				# TODO: Can we use the prototype more fully here?
				#

				my $command = '';

				if (defined($possible_proto) and $possible_proto != '@') {
					#
					# if it's not just a list operator, better not put in
					# parens, because they could change the semantics
					#

					$command = "$fnname " . join(",",@args);
				} else {
					#
					# Otherwise put in the parens to avoid any ambiguity: we
					# want to pass the given list of args to the function. It
					# would be better in perlfunc eval to get a reference to
					# the function and simply pass the args to it, but I
					# couldn't find any way to make that work with perl
					# builtins. You can't take a reference to CODE::sort, for
					# example.
					#

					$command .= "$fnname(" . join(",",@args) . ')';
				}

				return $command . $ampersand;
			}
		}

 		return '';
	},

	'perlscript' => sub {
		my $script = which(${$_[1]}[0]);

		if (defined($script) and -r $script) {
			#
			# let's see if it really looks like a perl script
			#

			my $sfh = new FileHandle($script);
			my $firstline = <$sfh>;

			$sfh->close();
			chomp $firstline;

			my $filename;
			my $switches;

			if (($filename,$switches) = 
				($firstline =~ m|^\#!\s*(/.*perl)\s+(.*)$|)
				and matches_perl_binary($filename)) {
				my $possibleMatch = $script;
				my %bangLineOptions = ();

				{
					local @ARGV = split(' ', $switches);

					#
					# All perl command-line options that take aruments as of 
					# Perl 5.00503:
					#

					getopt('DeiFlimMx', \%bangLineOptions); 
				}

				if ($bangLineOptions{w}) { 
					$possibleMatch .= " warnings"; 
					delete $bangLineOptions{w};
				}

				#
				# TODO: We could handle more options. [There are some we
				# can't. -d, -n and -p are popular ones that would be tough.]
				#

				if (scalar(keys %bangLineOptions) > 0) {
					print_debug("[[perlscript: skip $script, options $restOfLine.]]\n");
					return '';
				}

				return $possibleMatch;
			}
		}

		return '';
	},

	'executable' => sub {
		my $executable = which(${$_[1]}[0]);

		if (defined($executable)) { 
			shift @{$_[1]}; # OK to destroy the command line because we're
                            # going to match this strategy
			if (!$executable_expand_arguments) {
				return "$executable @{$_[1]}"; 
			}

			# No need to do glob_expansion, the system call will do that.

			@newargs = variable_expansion($_[1]);

			return "$executable @newargs";
		}

		return '';
	},

   'eval' => sub { return 'perl evaluation'; }
);


#
# void remove_signal_handlers()
#
# TODO: Is there a way to do this in a loop over something from the
# Config module? If so, should we use it? If we do, shouldn't we
# use the same mechanism to set up the signal handlers in the first
# place?
#

sub remove_signal_handlers
{
	$SIG{INT}   = undef;
	$SIG{QUIT}  = undef;
	$SIG{USR1}  = undef;
	$SIG{USR2}  = undef;
	$SIG{CONT}  = undef;
	$SIG{STOP}  = undef;
	$SIG{TSTP}  = undef;
	$SIG{TTIN}  = undef;
	$SIG{TTOU}  = undef;
	$SIG{CHLD}  = undef;
	$SIG{WINCH} = undef;
}


#
# void give_terminal_to (int PID) 
#
# Make pid the foreground process of the terminal controlling STDIN.
#

sub give_terminal_to
{
	local $SIG{TSTP}  = 'IGNORE';
	local $SIG{TTIN}  = 'IGNORE';
	local $SIG{TTOU}  = 'IGNORE';
	local $SIG{CHLD}  = 'IGNORE';

	tcsetpgrp(STDIN,$_[0]);
}


%strategy_eval = (
	'comment' => sub { return undef; },

	'bang' => sub {
		my ($string) = (${$_[0]} =~ m/!(.*)$/);

		my_system($string);

		return undef;
	},

	'built_in' => sub {
		my $command = shift @{$_[1]};

		return &{$psh::built_ins{$command}}("@{$_[1]}");
	},

	'perlscript' => sub {
		my ($script, @options) = split(' ',$_[2]);
		my @arglist = @{$_[1]};

		shift @arglist; # Get rid of script name
		my $fgflag = 1;

		if (scalar(@arglist) > 0) {
			my $lastarg = pop @arglist;

			if ($lastarg =~ m/\&$/) {
				$fgflag = 0;
				$lastarg =~ s/\&$//;
			}

			if ($lastarg) { push @arglist, $lastarg; }
		}

		print_debug("[[perlscript $script, options @options, args @arglist.]]\n");

		my $pid;

		unless ($pid = fork) { #child
			my %opts = ();

			foreach (@options) { $opts{$_} = 1; }

			#
			# Fine to do this explicitly, since scripts are
			# always executed in package main.
			#

			package main;

			open(STDIN,"-");
			open(STDOUT,">-");
			open(STDERR,">-");

			remove_signal_handlers();
			setpgid(getpid(),getpid()); # Vital, see protected_eval

			if ($fgflag) { give_terminal_to(getpid()); }

			#
			# TODO: Is it possible/desirable to put main in the pristine
			# state that it typically is in when a script starts up,
			# i.e. undefine all routines and variables that the user has set?
			#

			local @ARGV = @arglist;
			local $^W;

			if ($opts{warnings}) { $^W = 1; }
			else                 { $^W = 0; }

			do $script;

			exit 0;
		}

		# the "real me"
		#
		# TODO: This code needs to be unified with my_system; and we need
		#       to provide an easy, modular way to allow other strategies
		#       like eval to fork a background job if the command line
		#       ends in &
		#        

		setpgid($pid,$pid);
		create_job($pid, "$script @arglist", !$fgflag);

		if ($fgflag) { wait_for_system($pid, 1); }

		return undef;
	},

	'executable' => sub { my_system("$_[2]"); return undef; },

	#
	# TODO: Is this the best way to manage the package context?
	#
	# Consider:
	#
	#     my $pkg = package;
	#     package psh;
	#     ...
	#     package $pkg;
	#     eval ...
	#     package $psh;
	#
	# The idea here is to not force "package main" as it does now.
	#
	# [gtw 1999 Nov 22: The above is a nice idea, but I believe neither
	#    'my $pkg = package;' nor 'package $pkg;' is valid Perl syntax.
	#    As far as I can see, the only way to allow different package
	#    contexts would be to keep track of the desired package by a
	#    built-in command, and prepending the desired package to every
	#    evaluation. Toward that possible goal, I have added a variable
	#    $psh::eval_preamble which is prepended to every eval. This
	#    defaults to 'package main;'. To allow selecting other packages
	#    for evaluation, its value could be manipulated.
	# ]
	#

	'eval'     => sub { return protected_eval(${$_[0]}, 'eval'); },

	'perlfunc' => sub { return protected_eval($_[2],    'eval'); }
);


#
# void handle_message (string MESSAGE, string FROM = 'eval')
#
# handles any message that an eval might have returned. Distinguishes
# internal messages from psh's signal handlers from all other
# messages. It displays internal messages with print_out or does
# nothing with them if FROM = 'main_loop'. It displays other messages with
# print_error, and if FROM = 'main_loop', psh dies in addition.
#

sub handle_message
{
	my ($message, $from) =  @_;

	if (!defined($from)) { $from = 'eval'; }

	chomp $message;

	if ($message) {
		if ($message =~ m/^SECRET $bin:(.*)$/s) {
			if ($from ne 'main_loop') { print_out("$1\n"); }
		} else {
			print_error("$from error ($message)!\n");
			if ($from eq 'main_loop') { die("Internal psh error."); }
		}
	}
}


#
# array evl(string LINE, [array STRATEGIES])
#
# evaluate a single logical "line" of input (which may have been built
# up from several actual lines by the process loop). This function
# simply calls decompose on LINE, and then tries the evaluation
# strategies in @psh::strategies in order. If no strategy matches, it
# prints an error message. If some strategy does match, it calls the
# evaluation function for that strategy and returns its value. If the
# STRATEGIES argument is supplied, it overrides @psh::strategies.
#

sub evl 
{
	my ($line, @use_strats) = @_;
	my @words = decompose($line);

	if (!defined(@use_strats) or scalar(@use_strats) == 0) {
		@use_strats = @strategies;
	}

	my $qSucceeded = 0;
	my @result;

	for my $strat (@use_strats) {
		if (!defined($psh::strategy_which{$strat})) {
			print_warning("$bin: WARNING: unknown strategy '$strat'.\n");
			next;
		}

		my $how = &{$psh::strategy_which{$strat}}(\$line,\@words);

		if ($how) {
			print_debug("Using strategy $strat by $how\n");
			eval {
				@result = &{$psh::strategy_eval{$strat}}(\$line,\@words,$how);
			};

			handle_message($@, $strat);
			$qSucceeded = 1;

			last;
		}
	}

	if (!$qSucceeded) {
		print_error("Can't determine how to evaluate '$line'.\n");
		return undef;
	}

	return @result;
}


#
# string read_until(string TERMINATOR, subr GET)
#
# Get successive lines via calls to GET until one of those
# entire lines matches the patterm TERMINATOR. Used to implement
# the `<<EOF` multiline quoting construct and brace matching;
#
# TODO: Undo any side effects of, e.g., m//.
#

sub read_until
{
	my ($terminator, $get) = @_;
	my $input;
	my $temp;

	$input = '';

	while (1) {
		$temp = &$get();
		last unless defined($temp);
		last if $temp =~ m/^$terminator$/;
		$input .= $temp;
	}

	return $input;
}


#
# void process(bool PROMPT, subr GET)
#
# Process lines produced by the subroutine reference GET until it
# returns undef. GET must be a reference to a subroutine which takes a
# string argument (the prompt, which may be empty) and returns the
# next line of input, or undef if there is none.
#
# Any output generated is handled by the various print_xxx routines
#
# The prompt is printed only if the PROMPT argument is true.  When
# sourcing files (like .pshrc), it is important to not print the
# prompt string, but for interactive use, it is important to print it.
#
# TODO: Undo any side effects, e.g. done by m//.
#

sub process
{
	my ($prompt, $get) = @_;
	local $cmd;

	while (1) {
		if ($prompt) {
			$input = &$get(prompt_string());
		} else {
			$input = &$get();
		}

		reap_children(); # Check wether we have dead children

		$cmd++;

		last unless defined($input);

		chomp $input;

		if ($input =~ m/^\s*$/) { next; }
		if ($input =~ m/<<([a-zA-Z_0-9\-]*)/) {
			my $terminator = $1;
			$input .= "\n";
			$input .= read_until($terminator, $get);
			$input .= "$terminator";
		} elsif ($input =~ m/\{\s*$/) {
			#
			# TODO: A better version of this would detect
			# unbalanced braces, and read until they balanced.
			#
			$input .= "\n";
			$input .= read_until('}', $get);
			$input .= '}';
		}

		my @result = evl($input);

		my $qEcho = 0;

		if (ref($echo) eq 'CODE') {
			$qEcho = &$echo(@result);
		} elsif (ref($echo)) {
			print_warning("$bin: WARNING: \$psh::echo is neither a SCALAR nor a CODE reference.\n");
		} else {
			if ($echo) { $qEcho = defined_and_nonempty(@result); }
		}

		if ($qEcho) {
			if (scalar(@result) > 1) {
				my $n = scalar(@val);
				push @val, \@result;
				print_out("\$psh::val[$n] <- [@result]\n");
			} else {
				my $n = scalar(@val);
				my $res = $result[0];
				push @val, $res;
				print_out("\$psh::val[$n] <- $res\n");
			}
		}
	}
}


#
# bool defined_and_nonempty(args)
#
# returns true if it has any defined, nonempty args
#

sub defined_and_nonempty
{
	if (!defined(@_))    { return 0; }
	if (scalar(@_) == 0) { return 0; }

	if (scalar(@_) == 1) {
		if (!defined($_[0])) { return 0; }
		if ($_[0] eq '')     { return 0; }

		return 1;
	}

	return 1; # multiple args always true
}


#
# void process_file(string FILENAME)
#
# process() the lines of FILENAME
#

sub process_file
{
	my ($path) = @_;

	print_debug("[[PROCESSING FILE $path]]\n");

	if (!-r $path) {
		print_error("$bin: Cannot read script `$path'\n");
		return;
	}
	
	my $pfh = new FileHandle($path,'r');

	if (!$pfh) {
		print_error("$bin: Cannot open script `$path'\n");
		return;
	}

	process(0, sub { return <$pfh>; }); # don't prompt

	$pfh->close();

	print_debug("[[FINISHED PROCESSING FILE $path]]\n");
}


#
# string prompt_string()
#
# Construct a prompt string.
#
# TODO: Should we have an entry for '\'?
#

%prompt_vars = (
	'd' => sub {
			my ($wday, $mon, $mday) = (localtime)[6, 4, 3];
			$wday = $wday[$wday];
			$mon  = $mon[$mon];
			return "$wday $mon $mday";
		},
	'h' => sub { return $host; },
	'H' => sub { return $longhost; },
	's' => sub {
			my $shell = $bin;
			$shell =~ s/^.*\///;
			return $shell;
		},
	'n' => sub { return "\n"; },
	't' => sub {
			my ($hour, $min, $sec) = (localtime)[2, 1, 0];
			return sprintf("%02d:%02d:%02d", $hour, $min, $sec);
		},
	'u' => sub {
			# Camel, 2e, p. 172: 'getlogin'.
			return getlogin || (getpwuid($>))[0] || "uid$>";
		},
	'w' => sub { return cwd; },
	'W' => sub { my $dir = cwd; $dir =~ s/^.*\///; return $dir },
	'#' => sub { return $cmd; },
	'$' => sub { return ($> ? '$' : '#'); }
);

sub prompt_string
{
	my $temp;

	#
	# First, get the prompt string from a subroutine or from the default:
	#

	if (ref($prompt) eq 'CODE') { # If it is a subroutine,
		$temp = &$prompt();
	} elsif (ref($prompt)) {      # If it isn't a scalar
		print_warning("$bin: Warning: \$psh::prompt is neither a SCALAR nor a CODE reference.\n");
		$temp = $default_prompt;
	} else {
		$temp = $prompt;
	}

	#
	# Now, subject it to substitutions:
    #
	# There are two kinds of escapes: (1) Single (non-digit) character, and (2) one or more
	# digits. The former are looked up in %prompt_vars, and the latter are mapped to ascii
	# characters.
	#

	while ($temp =~ m/^(.*)\\([0-9]+|[^0-9])(.*)$/) {
		my $sub;

		my ($save1, $code, $save2) = ($1, $2, $3);
		my $var = $prompt_vars{$code};

		if (ref $var eq 'CODE') {
			$sub = &$var();
 		} elsif($code =~ /[0-9]+/) {
 			# I want my colour prompt back!
 			if ($code =~ /^0/) { $sub = chr(oct($code)); }
 			else               { $sub = chr(hex($code)); }

		} else {
			print_warning("$bin: Warning: \$psh::prompt (`$temp') contains unknown escape sequence `\\$code'.\n");
			$sub = ''
		}

		{
			local $1;
			if ($sub =~ m/\\(.)/) {
				print_warning("$bin: Warning: Expansion of `\\$code' in prompt string yielded\n",
					  "     string containing `$1'. Stripping escape sequences from\n",
					  "     substitution.\n");
				$sub =~ s/\\(.)//g;
			}
		}

		$temp = $save1 . $sub . $save2
	}

	return $temp;
}


#
# readline_handler()
#
# Readline ^C handler.
#

sub readline_handler
{
    die "SECRET $bin: Signal $sig\n";
}


#
# string iget(string PROMPT)
#
# Interactive line getting routine. If we have a
# Term::ReadLine instance, use it and record the
# input into the history buffer. Otherwise, just
# grab an input line from STDIN.
#
# readline() returns a line WITHOUT a "\n" at the
# end, and <STDIN> returns one WITH a "\n", UNLESS
# the end of the input stream occurs after a non-
# newline character. So, first we chomp() the
# output of <STDIN> (if we aren't using readline()),
# and then we tack the newline back on in both
# cases. Other code later strips it off if necessary.
#
# iget() uses PROMPT as the prompt; this may be the empty string if no
# prompting is necessary.
#
# TODO: Handle ^D nicely (i.e. allow log out or at least print "\n";)
#

sub iget
{
	my $prompt = shift;
	my $line;
	my $sigint = 0;

	local $SIG{'INT'}=\&readline_handler;
 
	do {
		if ($sigint) {
			print_out("\nInterrupted!\n");
			$sigint=0;
		}
		# Trap ^C in an eval.  The sighandler will die which will be
		# trapped.  Then we reprompt
		if ($term) {
			eval { $line = $term->readline($prompt); } # trap ^C which will die;
		} else {
			eval {
				print $prompt;
				$line = <STDIN>;
			}
		}
		if ($@) { $sigint=1; }
	} while ($sigint);

	chomp $line;

# [ gtw: Why monkey with the input? If we take out whitespace now,
#   we'll never know if it was there. Better wait.
# ]

#	$line =~ s/^\s+//;
#	$line =~ s/\s+$//;

	if ($term and $line !~ m/^\s*$/) {
               $term->addhistory($line); 

		if ($save_history && !$readline_saves_history) {
		  my $fhist = new FileHandle($psh::history_file, 'a');
		  $fhist->print("$line\n");
		  $fhist->close();
		}
	}

	return $line . "\n";         # This is expected by other code.
}


#
# string news()
#
# Return the news

sub news 
{
	if (-r $news_file) {
		return `cat $news_file`;
	} else {
		return '';
	}
}


#
# void initialize()
#

sub initialize
{
	$|                           = 1;                # Set ouput autoflush on

	#
    # Set up accessible psh:: package variables:
	#

	$prompt                      = $default_prompt;  # Set default prompt
    @strategies                  = @default_strategies;
	$eval_preamble               = 'package main;';
    $currently_active            = 0;
	$save_history                = 1;
	$history_length              = 50;
	$perlfunc_expand_arguments   = 1;
	$executable_expand_arguments = 0;
	$cmd                         = 1;

	$bin                         = $0;
	$bin                         =~ s/.*\///;

	$longhost                    = qx(hostname);
	chomp $longhost;

	$host                        = qx(hostname -s);
	chomp $host;

	$news_file                   = "$bin.NEWS";
	$history_file                = "$ENV{HOME}/.${bin}_history";

	%built_ins = (
		      '.'        => \&builtin_source,
		      'alias'    => \&builtin_alias,
		      'bg'       => \&builtin_bg,
		      'cd'       => \&builtin_cd,
		      'exit'     => \&builtin_exit,
		      'fg'       => \&builtin_fg,
		      'jobs'     => \&builtin_jobs,
		      'kill'     => \&builtin_kill,
		      'readline' => \&builtin_readline,
		      'which'    => \&builtin_which,
		      'source'   => \&builtin_source,
	);

	#
	# TODO: Internationalize!
	#
	# Although, right now they can be overridden in the .pshrc file
	# via @psh::wday = qw(Dom Lun Mar Mie Jue Vie Sab).
	#

	@wday      = qw(Sun Mon Tue Wed Thu Fri Sat);
	@mon       = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);

	@val = ();
}


#
# void process_rc()
#
# Search for and process .pshrc files.
#

sub process_rc
{
	my @rc;
	my $rc_name = ".pshrc";

	print_debug("[ LOOKING FOR .pshrc ]\n");

	if ($opt{'r'}) {
		push @rc, $opt{'r'};
	} else {
		if ($ENV{HOME}) { push @rc, "$ENV{HOME}/$rc_name"; }
		push @rc, "$rc_name" unless $ENV{HOME} eq cwd;
	}

	foreach my $rc (@rc) {
		if (-r $rc) {
		        print_debug("[ PROCESSING $rc ]\n");
			process_file($rc);
		}
	}

	if (defined($term) and $save_history) {
		if ($readline_saves_history) {
			$term->ReadHistory($psh::history_file);
		} else {
		  my $fhist = new FileHandle($psh::history_file);
		  if ($fhist) {
               while (<$fhist>) {
                   chomp;
                   $term->addhistory($_);
               }
               $fhist->close();
		  }
		}
	}
}


#
# void process_args()
#
# Process files listed on command-line.
#

sub process_args
{
	print_debug("[ PROCESSING @ARGV FILES ]\n");

	foreach my $arg (@ARGV) {
		if (-r $arg) {
		        print_debug("[ PROCESSING $arg ]\n");
			process_file($arg);
		}
	}
}


#
# void main_loop()
#
# Determine whether or not we are operating interactively,
# set up the input routine accordingly, and process the
# input.
#

sub main_loop
{
	my $interactive = (-t STDIN) and (-t STDOUT);
	my $get;

	print_debug("[[STARTING MAIN LOOP]]\n");

	if ($interactive) { $get = \&iget;                  }
	else              { $get = sub { return <STDIN>; }; }

	process($interactive, $get);
}

# bool is_number(ARG)
#
# Return true if ARG is a number
#

sub is_number
{
	my ( $test)=@_;
	return $test=~/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/o;
}

sub print_warning
{
	print STDERR @_;
}

sub print_debug
{
	print STDERR @_ if $debugging;
}

sub print_error
{
	print STDERR @_;
}

sub print_out
{
	print STDOUT @_;
}


#
# void symbols()
#
# Print out the symbols of each type used by a package. Note: in testing,
# it bears out that the filehandles are present as scalars, and that arrays
# are also present as scalars. The former is not particularly surprising,
# since they are implemented as tied objects. But, use vars qw(@X) causes
# both @X and $X to show up in this display. This remains mysterious.
#

sub symbols
{
	my $pack = shift;
	my (@ref, @scalar, @array, @hash, @code, @glob, @handle);
	my @sym;

	{
		no strict qw(refs);
		@sym = keys %{*{"${pack}::"}};
	}

	for my $sym (sort @sym) {
		next unless $sym =~ m/^[a-zA-Z]/; # Skip some special variables
		next if     $sym =~ m/::$/;       # Skip all package hashes

		{
			no strict qw(refs);

			push @ref,    "\$$sym" if ref *{"${pack}::$sym"}{SCALAR} eq 'REF';
			push @scalar, "\$$sym" if ref *{"${pack}::$sym"}{SCALAR} eq 'SCALAR';
			push @array,  "\@$sym" if ref *{"${pack}::$sym"}{ARRAY}  eq 'ARRAY';
			push @hash,   "\%$sym" if ref *{"${pack}::$sym"}{HASH}   eq 'HASH';
			push @code,   "\&$sym" if ref *{"${pack}::$sym"}{CODE}   eq 'CODE';
#			push @glob,   "\*$sym" if ref *{"${pack}::$sym"}{GLOB}   eq 'GLOB';
			push @handle, "$sym"   if ref *{"${pack}::$sym"}{FILEHANDLE};
		}
	}

	print_out("Reference: ", join(' ', @ref),    "\n");
	print_out("Scalar:    ", join(' ', @scalar), "\n");
	print_out("Array:     ", join(' ', @array),  "\n");
	print_out("Hash:      ", join(' ', @hash),   "\n");
	print_out("Code:      ", join(' ', @code),   "\n");
#	print_out("Glob:      ", join(' ', @glob),   "\n");
	print_out("Handle:    ", join(' ', @handle), "\n");
}



##############################################################################
##############################################################################
##
## SUBROUTINES: Signal Handlers
##
##############################################################################
##############################################################################



#
# void signal_handler( string SIGNAL )
#

sub signal_handler
{
	my ($sig) = @_;
	
	if ($psh::currently_active > 0) {
		print_debug("Received signal SIG$sig, sending to $psh::currently_active\n");

		kill $sig, $psh::currently_active;
	} elsif ($currently_active < 0) {
		print_debug("Received signal SIG$sig, sending to Perl code\n");

		die "SECRET $bin: Signal $sig\n";
	} else {
		print_debug("Received signal SIG$sig, die-ing\n");
	}

	$SIG{$sig} = \&signal_handler;
}


#
# ignore_handler()
#
# TODO: Do we need to re-install the ignore handler, like we do for the
# generic handler?
#
# From Markus: Apparently letting a signal execute an empty sub is not the same
# as setting the sighandler to IGNORE
#

sub ignore_handler
{
#	my ($sig) = @_;
#	$SIG{$sig} = \&ignore_handler;
}


#
# resize_handler()
#
# TODO: Do we need to re-install the resize handler, like we do for the
# generic handler?
#

sub resize_handler
{
#	my ($sig) = @_;
	my ($cols, $rows) = (80, 24);

	eval {
		($cols,$rows)= &Term::Size::chars();
	};

	if(($cols > 0) && ($rows > 0)) {
		$ENV{COLUMNS} = $cols;
		$ENV{LINES}   = $rows;
	}

#	$SIG{$sig} = \&resize_handler;
}



##############################################################################
##############################################################################
##
## SUBROUTINES: Support
##
##############################################################################
##############################################################################



#
# void my_system(string COMMAND_LINE)
#
# Executes COMMAND_LINE via system, noticing and stripping final '&'
# to allow jobcontrol
#

sub my_system
{
	my($call) = @_;

	#
	# TODO: This is an absolute hack... we need
	# a full parser for quoting and all special
	# characters soon!!
	#
	
	my $fgflag = 1;

	if ($call =~ /^(.*)\&\s*$/) {
		$call= $1;
		$fgflag=0;
	}

	eval {
	        # Markus Peter's version; may be better in some ways,
	        # but I couldn't find any way to do the setpgrp
	        #  open(TMPOUT,">-");
		#  open(TMPIN,"-");
		#  my $pid= open2(">&TMPOUT", "<&TMPIN", $call);
	        my $pid;
		unless ($pid = fork) { #child
		  open(STDIN,"-");
		  open(STDOUT,">-");
		  open(STDERR,">&STDERR");
		  remove_signal_handlers();
		  setpgid(getpid(),getpid());
		  if ($fgflag) { give_terminal_to(getpid()); }
		  exec $call;
		  print_error("Error (exec $call) failed.");
		  exit -1;
		}
		# the real me
		setpgid($pid,$pid);
		create_job($pid, $call, !$fgflag);
		if( $fgflag)
		{
			wait_for_system($pid, 1);
		}
	};

	print_debug("Status $@\n") if $@;
}


#
# void wait_for_system(int PID, [bool QUIET_EXIT])
#
# Waits for a program to be stopped/ended, prints no message on normal
# termination if QUIET_EXIT is specified and true.
#

sub wait_for_system
{
	my($pid, $quiet) = @_;
        if (!defined($quiet)) { $quiet = 0; }

	my $psh_pgrp = getpgrp;

	my $pid_status = -1;
	while (1) {
	  print_debug("[[About to give the terminal to $pid.]]\n");
	  give_terminal_to($pid);
	  #
	  # TODO: Is the following line necessary? Should we check to
	  # make sure te job exists after we do it? This is tricky
	  # stuff.
	  #
	  if (!is_job_running($pid)) { continue_job($pid); }
	  my $returnpid;
	  {
	    local $psh::currently_active = $pid;
	    $returnpid = waitpid($pid, &WUNTRACED);
	    $pid_status = $?;
	  }
	  give_terminal_to($psh_pgrp);
	  print_debug("[[Just gave myself back the terminal. $pid $returnpid $pid_status]]\n");
	  if ($returnpid == $pid) { last; }
	  # TODO: What does $returnpid != $pid mean? Could it in fact
	  # happen?
	  print_error("Waiting for $pid, got $returnpid. The most recent author didn't know what that meant. Please fix. \n");
	}
	handle_wait_status($pid, $pid_status, $quiet);
      }

#
# void handle_wait_status(int PID, int STATUS, bool QUIET_EXIT)
#
# Take the appropriate action given that waiting on PID returned
# STATUS. Normal termination is not reported if QUIET_EXIT is true.
#

sub handle_wait_status {
  my ($pid, $pid_status, $quiet) = @_;
  # Have to obtain these before we potentially delete the job
  my $command = get_job_command($pid);
  my $visindex= get_job_number($pid);
  my $verb='';
  
  if (&WIFEXITED($pid_status)) {
    if (!$quiet) { $verb = 'Done'; }
    delete_from_joblist($pid);
  } elsif (&WIFSIGNALED($pid_status)) {
    $verb = 'Terminated (signal ' . WTERMSIG($pid_status) . ')';
    delete_from_joblist($pid);
  } elsif (&WIFSTOPPED($pid_status)) {
    $verb = 'Stopped (signal ' . WSTOPSIG($pid_status) . ')';
    record_job_running($pid,0);
  }
  if ($verb) {
    print_out( "[$visindex] $verb $pid $command\n");
  }
}


#
# void reap_children()
#
# Checks wether any children we spawned died
#

sub reap_children
{
	for($i = 0; $i <= $#jobs_order; $i++) {
		my $visindex = $i+1;
		my $pid      = $jobs_order[$i];
		my $command  = get_job_command($pid);

	        my $retval = waitpid($pid, &WNOHANG);

    	        if ($retval == $pid) {
			delete_from_joblist( $pid);
			print_out( "[$visindex] Done $pid $command\n");
                } elsif ($retval < 0) { # process no longer exists
		        delete_from_joblist( $pid);
                        print_error( "[$visindex] Error, assuming done $pid $command\n");
		}
	}
}

#
# void create_job(int PID, string COMMAND, bool ADVERTISE)
#

sub create_job {
  my ($pid,$call,$advertise) = @_;
  $job_commands{$pid}=$call;
  record_job_running($pid,1);
  push(@jobs_order,$pid);
  if ($advertise) {
    my $visindex = scalar(@jobs_order);
    print_out("[$visindex] Background $pid $call\n");
  }
}

#
# void delete_from_joblist(int PID)
#

sub delete_from_joblist
{
	my($pid) =@_;

	delete $job_commands{$pid};
	delete $job_running{$pid};

	my $position;
	my $i;

	for($i=0; $i <= $#jobs_order; $i++) {
		last if($jobs_order[$i] == $pid);
	}

	splice(@jobs_order,$i,1);

	if ($currently_active == $pid) { $currently_active = 0; }
}


#
# void restart_job(bool FOREGROUND, int JOB_INDEX)
#

sub restart_job
{
	my ($fg_flag, $job_to_start) = @_;

	if ($job_to_start < 0) { # Search for the last job which is not running
		for ($i = $#jobs_order; $i >= 0; $i--) {
			my $pid = $jobs_order[$i];

			if(!is_job_running($pid)) {
				$job_to_start = $i;
				last;
			}
		}
		
		if ($job_to_start < 0) { # failing that, just use
                                         # highest-numbered job
		  $job_to_start = scalar(@jobs_order) - 1;
		}

		print_debug("Found job $job_to_start\n");
	}

	if ($job_to_start >- 1) {
		my $pid = $jobs_order[$job_to_start];
		my $command = get_job_command($pid);

		if ($command) {
			my $verb = 'Restart';
			my $qRunning = is_job_running($pid);
			if ($fg_flag) {
			  $verb = 'Foreground';
			} elsif ($qRunning) {
			  # bg request, and it's already running:
			  return;
			}
			my $visindex = get_job_number($pid);
			print_out("[$visindex] $verb $pid $command\n");
			if (!$qRunning) { continue_job($pid); }

			if($fg_flag) {
#				tcsetpgrp($pid); # TODO: Is this right?
				eval { wait_for_system($pid, 0); };
			}
		}
	}
}


#
# Tries to find executables for possible completions
# TODO: This is sloooow... but probably not only because
# of searching the whole path but also because of the way
# Term::ReadLine::Gnu works... hmm
#

sub try_executable_completion
{
	my ($cmd, $state) = @_;

	if (!$state)
	{
		my @path           = split(':', $ENV{PATH});
		my $old_cwd        = cwd;
		@completion_buffer = ();

		foreach my $dir (@path) {
			chdir abs_path($dir);
			push( @completion_buffer, grep { -x } glob "$cmd*" );
		}

		chdir $old_cwd;
	}

	return shift @completion_buffer;
}


#
# custom_completion()
#
# Main completion hook
#

sub custom_completion
{
	my ($text, $line, $start, $end) = @_;
	my $attribs                     = $term->Attribs;
	my @tmp;

	if (substr($line, $start, 1) eq "~") {
		return $term->completion_matches($text,
			$attribs->{username_completion_function});
	}

	#
	# Only return if executable match found something, otherwise try
	# filename completion
	#

	if (substr($line, 0, $start) =~ /^\s*$/) { # First word
		@tmp = $term->completion_matches($text, \&try_executable_completion);
		return @tmp if defined @tmp;
	}

	return $term->completion_matches($text,
		   $attribs->{filename_completion_function});
}

# Utility functions for keeping track of jobs.

# It would be nicer to have a little Job class, instead of this loose
# association of functions which are kind of like the methods of a
# class. 

#
# int get_job_number(int PID)
#
# Returns the visible number of a job or -1 if theres no such job
# TODO: Is there an array search function in perl except grep?
# I don't remember...
#

sub get_job_number
{
	my ($pid) = @_;

	for ($i = 0; $i <= $#jobs_order; $i++) {
		return $i + 1 if ($jobs_order[$i] == $pid);
	}

	return -1;
}

#
# bool job_exists(int PID) 
#
# Returns true if PID is the pid of a job currently being controlled
# by psh
#

sub job_exists {
  my ($pid) = @_;
  return exists($job_commands{$pid});
}


#
# string get_job_command(int PID) 
#
# Returns the command that was used to kick off the job with the given
# PID, or undef if there is no such job
#

sub get_job_command
{
	my ($pid) = @_;
	return $job_commands{$pid};
}


#
# bool is_job_running(int PID) 
#
# Returns true if the job with the given PID exists and is currently
# running (as far as psh can tell), false otherwise.
#
# Also checks wether any untraced children terminated
# (therefore the strange while is necessary)
#

sub is_job_running
{
	my ($pid)     = @_;
	my $returnpid;

	while (($returnpid = waitpid($pid, &WNOHANG | &WUNTRACED)) > 0) {
		$returnpid = waitpid($pid, &WNOHANG | &WUNTRACED);
		if ($returnpid == $pid) { handle_wait_status($returnpid, $?); }
	}

	return $job_running{$pid};
}


#
# void record_job_running(int PID, bool FLAG)
#
# Set the internal record of whether PID is running to FLAG: true
# means it is running.
#

sub record_job_running
{
	my ($pid, $flag)   = @_;
	$job_running{$pid} = $flag;
}


#
# void continue_job(int PID) 
#
# send SIGCONT to PID and record that (we think) it's now running
#

sub continue_job
{
	my ($pid) = @_;
	kill 'CONT', $pid;
	record_job_running($pid, 1);
}



##############################################################################
##############################################################################
##
## MAIN:
##
##############################################################################
##############################################################################



initialize;
process_rc;

if (@ARGV) {
	process_args;
} else {
  while (1) {
   eval { main_loop; };
   handle_message($@,'main_loop');
  }
}

exit 0;


#
# End of file.
#

