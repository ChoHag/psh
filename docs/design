psh2 design and philosophy
--------------------------

psh1 was basically a shell executing perl code. If input matched certain
characteristics, it was recognized as a "shell command", but perl
execution always was the final fallback.

psh2 is a shell acting as a shell written in perl. Executing perl is
not the primary function anymore.

psh2 has actually a straightforward, parsable syntax. The grammar is not
ambigous. The grammar tries to avoid relying on whitespace as much as possible
(unlike sh-derivates).

psh2 is no POSIX shell. It already broke with POSIX in the important regard of redirection syntax, so we can as well not care about it in other respects. We in fact already do this, so for example $( ) and ${ } have the exactly opposite meaning in the POSIX standard. We exchanged the meanings to have a more consistent syntax.

psh1' evaluation strategies do not exist in psh2 anymore in the same form.
Pluggable evaluation strategies still exist - to add additional behaviours -
but strategies like starting an executable or a builtin are hardcoded.

psh1 was delivered with its own homebrew localization system. As only
the German locale was ever up to date, and nobody seemed to use them
anyway, localization is now less a priority. We switched to Locale::gettext
- if someone absolutely wants a different locale he should be able to
install an additional dependancy.

Windows support was temporarily dropped but could be added again. As I do
not use Windows regularly, the port of psh1 was usually broken anyway.



SPEED AND LIMITATIONS

Depending on the exact commands, psh2 is between 2-5 times as fast as
psh1 and between 3-10 times slower than bash. Startup time of psh2
is largely determined by the time perl needs to read in the
files belonging to psh2.

All versions of psh are designed for interactive use. We believe that
in an interactive environment, neither the large memory usage of B<psh>
(between 2 and 6 MB, depending on your system, perl version and psh
configuration) nor the slower speed compared to pure perl or the
different other shells are that important.
		

COMPONENTS

- the Psh2 main object - containing basic infrastructur and accessors
- the Psh2::Parser module (no object) which tokenizes input. Tokenization
in this context means much more than in psh1: the parser already decides
which evaluation strategies to use
- an OS-dependant part: Psh2::Unix (and the unimplemented Psh2::Windows) which
is handling filesystem, jobs creation and management
- one of the available frontends objects. The frontends take care of fetching input from the user and feeding output back to him. psh1 only had a hard-coded Term::ReadLine frontend. psh2 will feature at least an own, pure perl frontend as well as a Term::ReadLine and Term::EditLine frontend
- Language modules: every "sublanguage" which is accessible from psh2 (initially Perl and C) has an own language module implementing support for that language.
- the Completer object is responsible for calculating possible completions for input. The wiring of tab completion itself is done in the frontends.



SYNTAX

Syntax in Pseudo-EBNF.

input := ( line \n ) ...
line := complexcommand [(; | &)  complexcommand] ...
complexcommand := basiccommand [pipe basiccommand] ...
basiccommand := command [redirection]
redirect := ( > | >& | >> | < ) [fd] filename ...
pipe := \| [fd]
fd := \[ (0-9|=GLOB|all|0-9=0-9) \]
command := languagename: code | builtin | function | executable |
           pluggablestrategy


"..." means: any number of elements, [] signifies optional components
| means an alternative

Support missing currently for: << (here-docs used as STDIN) <{ } and >{ }

<{ } and >{ } use named pipes


INFLUENCES AND OTHER SHELL

* rc - the Plan 9 shell (http://www.star.le.ac.uk/~tjg/rc/misc/td and "man rc")
* aibash - http://aibash.sourceforge.net/
* zsh - http://www.zsh.org
* eshell - http://www.newartisans.com/johnw/eshell.html
* our harmonic rivalry with Zoidberg - http://zoidberg.student.utwente.nl/
